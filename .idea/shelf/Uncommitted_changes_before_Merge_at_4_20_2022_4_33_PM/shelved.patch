Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"cfdde81c-4707-4876-8785-5499c7c87d54\" name=\"Changes\" comment=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\">\r\n      <change afterPath=\"$PROJECT_DIR$/.idea/Heap-20220411T212418.heaptimeline\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/ideaIC-2021.3.3.exe\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/unMineable.Miner.1.1.0-beta-mfi (1).zip\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Unconfirmed 544561.crdownload\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Unconfirmed 544561.crdownload\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n    <option name=\"UPDATE_TYPE\" value=\"REBASE\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"27caAMQ2lnINcfpumEXtAJpdlEo\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"autoscrollToSource\" value=\"true\" />\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"SHARE_PROJECT_CONFIGURATION_FILES\" value=\"true\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python._pydev_execfile\">\r\n    <configuration name=\"_pydev_execfile\" type=\"PythonConfigurationType\" factoryName=\"Python\" singleton=\"false\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Google\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"C:\\Users\\andjo\\Desktop\\NEw\\Goldie\\venv\\Scripts\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$APPLICATION_HOME_DIR$/jbr/bin\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$APPLICATION_HOME_DIR$/plugins/python-ce/helpers/pydev/_pydev_imps/_pydev_execfile.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"true\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"PythonConfigurationType\" factoryName=\"Python\" singleton=\"false\">\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"C:\\Users\\andjo\\Desktop\\NEw\\Goldie\\venv\\Scripts\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$APPLICATION_HOME_DIR$/jbr/bin\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <module name=\"\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$APPLICATION_HOME_DIR$/jbr/bin/asda\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"true\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"asda\" type=\"PythonConfigurationType\" factoryName=\"Python\" singleton=\"false\" nameIsGenerated=\"true\">\r\n      <module name=\"Google\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"C:\\Users\\andjo\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\demo\\PyCharmLearningProject\\venv\\Scripts\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"C:/Program Files\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"C:/Program Files/JetBrains\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"true\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"linecache\" type=\"PythonConfigurationType\" factoryName=\"Python\" singleton=\"false\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Google\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"C:\\Users\\andjo\\Desktop\\NEw\\Goldie\\venv\\Scripts\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$APPLICATION_HOME_DIR$/jbr/bin\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$USER_HOME$/AppData/Local/Programs/Python/Python39/Lib/linecache.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"true\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"tokenize\" type=\"PythonConfigurationType\" factoryName=\"Python\" singleton=\"false\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Google\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"C:\\Users\\andjo\\Desktop\\NEw\\Goldie\\venv\\Scripts\\python.exe\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$APPLICATION_HOME_DIR$/jbr/bin\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$USER_HOME$/AppData/Local/Programs/Python/Python39/Lib/tokenize.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"true\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Python.asda\" />\r\n      <item itemvalue=\"Python.traceback\" />\r\n      <item itemvalue=\"Python.linecache\" />\r\n      <item itemvalue=\"Python.tokenize\" />\r\n      <item itemvalue=\"Python._pydev_execfile\" />\r\n      <item itemvalue=\"tox.xxx.py\" />\r\n      <item itemvalue=\"Compound.Goldie\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python._pydev_execfile\" />\r\n        <item itemvalue=\"Python.tokenize\" />\r\n        <item itemvalue=\"Python.linecache\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"cfdde81c-4707-4876-8785-5499c7c87d54\" name=\"Changes\" comment=\"\" />\r\n      <created>1649621686245</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1649621686245</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\">\r\n      <created>1649623545501</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649623545501</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\">\r\n      <created>1649623669110</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649623669110</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\">\r\n      <created>1649687545624</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649687545624</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\">\r\n      <created>1649688408639</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649688408639</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\">\r\n      <created>1649735280275</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649735280275</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"6\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"BEK_SORT_TYPE\" value=\"1\" />\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision f7993c5a5ea97154f180c6b4f2622e4d15c72fe0)
+++ b/.idea/workspace.xml	(date 1650490152468)
@@ -1,92 +1,179 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="ArtifactsWorkspaceSettings">
+    <artifacts-to-build>
+      <artifact name="Test" />
+    </artifacts-to-build>
+  </component>
   <component name="ChangeListManager">
     <list default="true" id="cfdde81c-4707-4876-8785-5499c7c87d54" name="Changes" comment="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
-      <change afterPath="$PROJECT_DIR$/.idea/Heap-20220411T212418.heaptimeline" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/ideaIC-2021.3.3.exe" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/unMineable.Miner.1.1.0-beta-mfi (1).zip" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Unconfirmed 544561.crdownload" beforeDir="false" afterPath="$PROJECT_DIR$/Unconfirmed 544561.crdownload" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
     <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="ExternalProjectsManager">
+    <system id="GRADLE">
+      <state>
+        <task path="$APPLICATION_HOME_DIR$">
+          <activation />
+        </task>
+        <projects_view />
+      </state>
+    </system>
+  </component>
+  <component name="Git.Merge.Settings">
+    <option name="BRANCH" value="991" />
   </component>
   <component name="Git.Settings">
-    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
-    <option name="UPDATE_TYPE" value="REBASE" />
+    <excluded-from-favorite>
+      <branch-storage>
+        <map>
+          <entry type="LOCAL">
+            <value>
+              <list>
+                <branch-info repo="$PROJECT_DIR$" source="master" />
+              </list>
+            </value>
+          </entry>
+        </map>
+      </branch-storage>
+    </excluded-from-favorite>
+    <option name="PREVIOUS_COMMIT_AUTHORS">
+      <list>
+        <option value="sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;" />
+        <option value="andrew1235665" />
+      </list>
+    </option>
+    <option name="PUSH_TAGS">
+      <GitPushTagMode>
+        <option name="argument" value="--tags" />
+        <option name="title" value="All" />
+      </GitPushTagMode>
+    </option>
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$" value="f7993c5a5ea97154f180c6b4f2622e4d15c72fe0" />
+      </map>
+    </option>
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/../D" />
+    <option name="ROOT_SYNC" value="DONT_SYNC" />
+    <option name="SIGN_OFF_COMMIT" value="true" />
+  </component>
+  <component name="GitSEFilterConfiguration">
+    <file-type-list>
+      <filtered-out-file-type name="LOCAL_BRANCH" />
+      <filtered-out-file-type name="REMOTE_BRANCH" />
+      <filtered-out-file-type name="TAG" />
+      <filtered-out-file-type name="COMMIT_BY_MESSAGE" />
+    </file-type-list>
+  </component>
+  <component name="HighlightingSettingsPerFile">
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/test/test_emacs.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$USER_HOME$/AppData/Local/Programs/Python/Python39/Lib/tokenize.py" root0="FORCE_HIGHLIGHTING" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/modes/notemacs.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$APPLICATION_PLUGINS_DIR$/python-ce/helpers/pydev/pydevd.py" root0="FORCE_HIGHLIGHTING" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/modes/__init__.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/local_history1.patch" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/asyncio/__init__.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/modes/basemode.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/console/__init__.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/console/console.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/readline.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/asyncio/base_events.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/.idea/misc.xml" root0="FORCE_HIGHLIGHTING" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/keysyms/__init__.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/__init__.py" root0="SKIP_INSPECTION" />
+    <setting file="file://$PROJECT_DIR$/Portfolio _ Robinhood.html" root0="FORCE_HIGHLIGHTING" />
   </component>
   <component name="MarkdownSettingsMigration">
     <option name="stateVersion" value="1" />
   </component>
-  <component name="ProjectId" id="27caAMQ2lnINcfpumEXtAJpdlEo" />
+  <component name="ProblemsViewState">
+    <option name="selectedTabId" value="CurrentFile" />
+  </component>
+  <component name="ProjectId" id="27gmxPwz8Lhincg2Cptwtr8XG5m" />
+  <component name="ProjectLevelVcsManager">
+    <ConfirmationsSetting value="2" id="Add" />
+  </component>
   <component name="ProjectViewState">
-    <option name="autoscrollToSource" value="true" />
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
   <component name="PropertiesComponent">
+    <property name="ASKED_ADD_EXTERNAL_FILES" value="true" />
+    <property name="GitStage.ChangesTree.GroupingKeys" value="directory&#10;module&#10;repository" />
     <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
     <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
     <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
-    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
+    <property name="com.intellij.ide.scratch.ScratchImplUtil$2/New Scratch File" value="Python" />
+    <property name="last_opened_file_path" value="$APPLICATION_HOME_DIR$" />
+    <property name="project.structure.last.edited" value="SDKs" />
+    <property name="project.structure.proportion" value="0.15" />
+    <property name="project.structure.side.proportion" value="0.2" />
+    <property name="settings.editor.selected.configurable" value="preferences.externalDependencies" />
   </component>
-  <component name="RunManager" selected="Python._pydev_execfile">
-    <configuration name="_pydev_execfile" type="PythonConfigurationType" factoryName="Python" singleton="false" temporary="true" nameIsGenerated="true">
-      <module name="Google" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <option name="SDK_HOME" value="C:\Users\andjo\Desktop\NEw\Goldie\venv\Scripts\python.exe" />
-      <option name="WORKING_DIRECTORY" value="$APPLICATION_HOME_DIR$/jbr/bin" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$APPLICATION_HOME_DIR$/plugins/python-ce/helpers/pydev/_pydev_imps/_pydev_execfile.py" />
-      <option name="PARAMETERS" value="" />
-      <option name="SHOW_COMMAND_LINE" value="true" />
-      <option name="EMULATE_TERMINAL" value="false" />
-      <option name="MODULE_MODE" value="false" />
-      <option name="REDIRECT_INPUT" value="false" />
-      <option name="INPUT_FILE" value="" />
+  <component name="RecentsManager">
+    <key name="CopyFile.RECENT_KEYS">
+      <recent name="D:\Google" />
+    </key>
+  </component>
+  <component name="RunAnythingCache">
+    <option name="myCommands">
+      <command value="?" />
+      <command value="mvn deploy" />
+      <command value="python" />
+    </option>
+  </component>
+  <component name="RunDashboard">
+    <option name="configurationTypes">
+      <set>
+        <option value="PythonConfigurationType" />
+      </set>
+    </option>
+  </component>
+  <component name="RunManager" selected="Gradle.D:/Google">
+    <configuration name="Unnamed" type="CompoundRunConfigurationType">
+      <toRun name="Goldie" type="CompoundRunConfigurationType" />
       <method v="2" />
     </configuration>
-    <configuration default="true" type="PythonConfigurationType" factoryName="Python" singleton="false">
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <envs>
-        <env name="PYTHONUNBUFFERED" value="1" />
-      </envs>
-      <option name="SDK_HOME" value="C:\Users\andjo\Desktop\NEw\Goldie\venv\Scripts\python.exe" />
-      <option name="WORKING_DIRECTORY" value="$APPLICATION_HOME_DIR$/jbr/bin" />
-      <option name="IS_MODULE_SDK" value="false" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <module name="" />
-      <option name="SCRIPT_NAME" value="$APPLICATION_HOME_DIR$/jbr/bin/asda" />
-      <option name="PARAMETERS" value="" />
-      <option name="SHOW_COMMAND_LINE" value="true" />
-      <option name="EMULATE_TERMINAL" value="false" />
-      <option name="MODULE_MODE" value="false" />
-      <option name="REDIRECT_INPUT" value="false" />
-      <option name="INPUT_FILE" value="" />
+    <configuration name="D:/Google" type="GradleRunConfiguration" factoryName="Gradle">
+      <ExternalSystemSettings>
+        <option name="executionName" />
+        <option name="externalProjectPath" value="$APPLICATION_HOME_DIR$" />
+        <option name="externalSystemIdString" value="GRADLE" />
+        <option name="scriptParameters" value="--daemon" />
+        <option name="taskDescriptions">
+          <list />
+        </option>
+        <option name="taskNames">
+          <list />
+        </option>
+        <option name="vmOptions" />
+      </ExternalSystemSettings>
+      <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>
+      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
+      <DebugAllEnabled>false</DebugAllEnabled>
       <method v="2" />
     </configuration>
-    <configuration name="asda" type="PythonConfigurationType" factoryName="Python" singleton="false" nameIsGenerated="true">
+    <configuration name="__init__ (1)" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="Google" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
       <envs>
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
-      <option name="SDK_HOME" value="C:\Users\andjo\AppData\Local\JetBrains\PyCharmCE2021.3\demo\PyCharmLearningProject\venv\Scripts\python.exe" />
-      <option name="WORKING_DIRECTORY" value="C:/Program Files" />
-      <option name="IS_MODULE_SDK" value="false" />
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline" />
+      <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="C:/Program Files/JetBrains" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/../Testing/Lib/site-packages/pyreadline/__init__.py" />
       <option name="PARAMETERS" value="" />
-      <option name="SHOW_COMMAND_LINE" value="true" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
       <option name="MODULE_MODE" value="false" />
       <option name="REDIRECT_INPUT" value="false" />
@@ -119,101 +206,406 @@
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
       <envs>
-        <env name="PYTHONUNBUFFERED" value="1" />
+        <env name="PYTHONUNBUFFERED" value="3" />
       </envs>
-      <option name="SDK_HOME" value="C:\Users\andjo\Desktop\NEw\Goldie\venv\Scripts\python.exe" />
-      <option name="WORKING_DIRECTORY" value="$APPLICATION_HOME_DIR$/jbr/bin" />
+      <option name="SDK_HOME" value="D:\Testing\python.exe" />
+      <option name="WORKING_DIRECTORY" value="$USER_HOME$/AppData/Local/Programs/Python/Python39/Lib" />
       <option name="IS_MODULE_SDK" value="false" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
       <option name="SCRIPT_NAME" value="$USER_HOME$/AppData/Local/Programs/Python/Python39/Lib/tokenize.py" />
       <option name="PARAMETERS" value="" />
-      <option name="SHOW_COMMAND_LINE" value="true" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
       <option name="MODULE_MODE" value="false" />
       <option name="REDIRECT_INPUT" value="false" />
       <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
+    <configuration name="mvn" type="ShConfigurationType" temporary="true">
+      <option name="SCRIPT_TEXT" value="" />
+      <option name="INDEPENDENT_SCRIPT_PATH" value="true" />
+      <option name="SCRIPT_PATH" value="$APPLICATION_HOME_DIR$/plugins/maven/lib/maven3/bin/mvn" />
+      <option name="SCRIPT_OPTIONS" value="" />
+      <option name="INDEPENDENT_SCRIPT_WORKING_DIRECTORY" value="true" />
+      <option name="SCRIPT_WORKING_DIRECTORY" value="$APPLICATION_HOME_DIR$/plugins/maven/lib/maven3/bin" />
+      <option name="INDEPENDENT_INTERPRETER_PATH" value="true" />
+      <option name="INTERPRETER_PATH" value="" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="EXECUTE_IN_TERMINAL" value="true" />
+      <option name="EXECUTE_SCRIPT_FILE" value="true" />
+      <envs />
       <method v="2" />
     </configuration>
     <list>
-      <item itemvalue="Python.asda" />
+      <item itemvalue="Compound.Unnamed" />
+      <item itemvalue="Compound.Goldie" />
       <item itemvalue="Python.traceback" />
+      <item itemvalue="Python.__init__ (1)" />
       <item itemvalue="Python.linecache" />
       <item itemvalue="Python.tokenize" />
-      <item itemvalue="Python._pydev_execfile" />
       <item itemvalue="tox.xxx.py" />
-      <item itemvalue="Compound.Goldie" />
+      <item itemvalue="Shell Script.mvn" />
+      <item itemvalue="Gradle.D:/Google" />
     </list>
     <recent_temporary>
       <list>
-        <item itemvalue="Python._pydev_execfile" />
+        <item itemvalue="Gradle.D:/Google" />
+        <item itemvalue="Python.tokenize" />
+        <item itemvalue="Shell Script.mvn" />
         <item itemvalue="Python.tokenize" />
         <item itemvalue="Python.linecache" />
       </list>
     </recent_temporary>
   </component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+  <component name="SvnConfiguration">
+    <configuration>C:\Users\andjo\AppData\Roaming\Subversion</configuration>
+  </component>
   <component name="TaskManager">
-    <task active="true" id="Default" summary="Default task">
-      <changelist id="cfdde81c-4707-4876-8785-5499c7c87d54" name="Changes" comment="" />
-      <created>1649621686245</created>
-      <option name="number" value="Default" />
-      <option name="presentableId" value="Default" />
-      <updated>1649621686245</updated>
-    </task>
-    <task id="LOCAL-00001" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
-      <created>1649623545501</created>
+    <task id="LOCAL-00001" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649738054923</created>
       <option name="number" value="00001" />
       <option name="presentableId" value="LOCAL-00001" />
       <option name="project" value="LOCAL" />
-      <updated>1649623545501</updated>
+      <updated>1649740198299</updated>
     </task>
-    <task id="LOCAL-00002" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
-      <created>1649623669110</created>
+    <task id="LOCAL-00002" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649738217903</created>
       <option name="number" value="00002" />
       <option name="presentableId" value="LOCAL-00002" />
       <option name="project" value="LOCAL" />
-      <updated>1649623669110</updated>
+      <updated>1649738217903</updated>
     </task>
-    <task id="LOCAL-00003" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
-      <created>1649687545624</created>
+    <task id="LOCAL-00003" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649738352890</created>
       <option name="number" value="00003" />
       <option name="presentableId" value="LOCAL-00003" />
       <option name="project" value="LOCAL" />
-      <updated>1649687545624</updated>
+      <updated>1649738352890</updated>
     </task>
-    <task id="LOCAL-00004" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
-      <created>1649688408639</created>
+    <task id="LOCAL-00004" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649738545405</created>
       <option name="number" value="00004" />
       <option name="presentableId" value="LOCAL-00004" />
       <option name="project" value="LOCAL" />
-      <updated>1649688408639</updated>
+      <updated>1649738545405</updated>
     </task>
-    <task id="LOCAL-00005" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
-      <created>1649735280275</created>
+    <task id="LOCAL-00005" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649738967487</created>
       <option name="number" value="00005" />
       <option name="presentableId" value="LOCAL-00005" />
       <option name="project" value="LOCAL" />
-      <updated>1649735280275</updated>
+      <updated>1649738967487</updated>
+    </task>
+    <task id="LOCAL-00006" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649735869532</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1649735869532</updated>
+    </task>
+    <task id="LOCAL-00007" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649743360584</created>
+      <option name="number" value="00007" />
+      <option name="presentableId" value="LOCAL-00007" />
+      <option name="project" value="LOCAL" />
+      <updated>1649743360584</updated>
+    </task>
+    <task id="LOCAL-00008" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649744687785</created>
+      <option name="number" value="00008" />
+      <option name="presentableId" value="LOCAL-00008" />
+      <option name="project" value="LOCAL" />
+      <updated>1649744687785</updated>
     </task>
-    <option name="localTasksCounter" value="6" />
-    <servers />
+    <task id="LOCAL-00009" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649744690641</created>
+      <option name="number" value="00009" />
+      <option name="presentableId" value="LOCAL-00009" />
+      <option name="project" value="LOCAL" />
+      <updated>1649744690641</updated>
+    </task>
+    <task id="LOCAL-00010" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649744874919</created>
+      <option name="number" value="00010" />
+      <option name="presentableId" value="LOCAL-00010" />
+      <option name="project" value="LOCAL" />
+      <updated>1649744874919</updated>
+    </task>
+    <task id="LOCAL-00011" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649744943218</created>
+      <option name="number" value="00011" />
+      <option name="presentableId" value="LOCAL-00011" />
+      <option name="project" value="LOCAL" />
+      <updated>1649744943218</updated>
+    </task>
+    <task id="LOCAL-00012" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649745202017</created>
+      <option name="number" value="00012" />
+      <option name="presentableId" value="LOCAL-00012" />
+      <option name="project" value="LOCAL" />
+      <updated>1649745202017</updated>
+    </task>
+    <task id="Default" summary="Default task">
+      <changelist id="cfdde81c-4707-4876-8785-5499c7c87d54" name="Changes" comment="" />
+      <created>1649750375967</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1650151110808</updated>
+    </task>
+    <task id="LOCAL-00013" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649750383307</created>
+      <option name="number" value="00013" />
+      <option name="presentableId" value="LOCAL-00013" />
+      <option name="project" value="LOCAL" />
+      <updated>1649750383307</updated>
+    </task>
+    <task id="LOCAL-00014" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649750507966</created>
+      <option name="number" value="00014" />
+      <option name="presentableId" value="LOCAL-00014" />
+      <option name="project" value="LOCAL" />
+      <updated>1649750507966</updated>
+    </task>
+    <task id="LOCAL-00015" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649750791406</created>
+      <option name="number" value="00015" />
+      <option name="presentableId" value="LOCAL-00015" />
+      <option name="project" value="LOCAL" />
+      <updated>1649750791406</updated>
+    </task>
+    <task id="LOCAL-00016" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649750922317</created>
+      <option name="number" value="00016" />
+      <option name="presentableId" value="LOCAL-00016" />
+      <option name="project" value="LOCAL" />
+      <updated>1649750922317</updated>
+    </task>
+    <task id="LOCAL-00017" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649751067386</created>
+      <option name="number" value="00017" />
+      <option name="presentableId" value="LOCAL-00017" />
+      <option name="project" value="LOCAL" />
+      <updated>1649751067386</updated>
+    </task>
+    <task active="true" id="LOCAL-00018" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <changelist id="cfdde81c-4707-4876-8785-5499c7c87d54" name="Changes" comment="" />
+      <created>1649751090980</created>
+      <option name="number" value="00018" />
+      <option name="presentableId" value="LOCAL-00018" />
+      <option name="project" value="LOCAL" />
+      <updated>1650489836379</updated>
+    </task>
+    <task id="LOCAL-00019" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649786474102</created>
+      <option name="number" value="00019" />
+      <option name="presentableId" value="LOCAL-00019" />
+      <option name="project" value="LOCAL" />
+      <updated>1649786474102</updated>
+    </task>
+    <task id="LOCAL-00020" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649796009682</created>
+      <option name="number" value="00020" />
+      <option name="presentableId" value="LOCAL-00020" />
+      <option name="project" value="LOCAL" />
+      <updated>1649796009682</updated>
+    </task>
+    <task id="LOCAL-00021" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649826910359</created>
+      <option name="number" value="00021" />
+      <option name="presentableId" value="LOCAL-00021" />
+      <option name="project" value="LOCAL" />
+      <updated>1649826910359</updated>
+    </task>
+    <task id="LOCAL-00022" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649828047058</created>
+      <option name="number" value="00022" />
+      <option name="presentableId" value="LOCAL-00022" />
+      <option name="project" value="LOCAL" />
+      <updated>1649828047058</updated>
+    </task>
+    <task id="LOCAL-00023" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649828209609</created>
+      <option name="number" value="00023" />
+      <option name="presentableId" value="LOCAL-00023" />
+      <option name="project" value="LOCAL" />
+      <updated>1649828209609</updated>
+    </task>
+    <task id="LOCAL-00024" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649828620015</created>
+      <option name="number" value="00024" />
+      <option name="presentableId" value="LOCAL-00024" />
+      <option name="project" value="LOCAL" />
+      <updated>1649828620015</updated>
+    </task>
+    <task id="LOCAL-00025" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649908938279</created>
+      <option name="number" value="00025" />
+      <option name="presentableId" value="LOCAL-00025" />
+      <option name="project" value="LOCAL" />
+      <updated>1649908938279</updated>
+    </task>
+    <task id="LOCAL-00026" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1649909194019</created>
+      <option name="number" value="00026" />
+      <option name="presentableId" value="LOCAL-00026" />
+      <option name="project" value="LOCAL" />
+      <updated>1649909194019</updated>
+    </task>
+    <task id="LOCAL-00027" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650149522353</created>
+      <option name="number" value="00027" />
+      <option name="presentableId" value="LOCAL-00027" />
+      <option name="project" value="LOCAL" />
+      <updated>1650149522353</updated>
+    </task>
+    <task id="LOCAL-00028" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650149936848</created>
+      <option name="number" value="00028" />
+      <option name="presentableId" value="LOCAL-00028" />
+      <option name="project" value="LOCAL" />
+      <updated>1650149936848</updated>
+    </task>
+    <task id="LOCAL-00029" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650157329589</created>
+      <option name="number" value="00029" />
+      <option name="presentableId" value="LOCAL-00029" />
+      <option name="project" value="LOCAL" />
+      <updated>1650157329589</updated>
+    </task>
+    <task id="LOCAL-00030" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650207642366</created>
+      <option name="number" value="00030" />
+      <option name="presentableId" value="LOCAL-00030" />
+      <option name="project" value="LOCAL" />
+      <updated>1650207642366</updated>
+    </task>
+    <task id="LOCAL-00031" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650213878071</created>
+      <option name="number" value="00031" />
+      <option name="presentableId" value="LOCAL-00031" />
+      <option name="project" value="LOCAL" />
+      <updated>1650213878071</updated>
+    </task>
+    <task id="LOCAL-00032" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650232065340</created>
+      <option name="number" value="00032" />
+      <option name="presentableId" value="LOCAL-00032" />
+      <option name="project" value="LOCAL" />
+      <updated>1650232065340</updated>
+    </task>
+    <task id="LOCAL-00033" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650238091662</created>
+      <option name="number" value="00033" />
+      <option name="presentableId" value="LOCAL-00033" />
+      <option name="project" value="LOCAL" />
+      <updated>1650238091662</updated>
+    </task>
+    <task id="LOCAL-00034" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <created>1650244646566</created>
+      <option name="number" value="00034" />
+      <option name="presentableId" value="LOCAL-00034" />
+      <option name="project" value="LOCAL" />
+      <updated>1650244646566</updated>
+    </task>
+    <task id="LOCAL-00035" summary="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;">
+      <changelist id="cfdde81c-4707-4876-8785-5499c7c87d54" name="Changes" comment="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;" />
+      <created>1650308231273</created>
+      <option name="number" value="00035" />
+      <option name="presentableId" value="LOCAL-00035" />
+      <option name="project" value="LOCAL" />
+      <updated>1650489836379</updated>
+    </task>
+    <option name="localTasksCounter" value="36" />
+    <servers>
+      <GitHub url="https://github.com" />
+    </servers>
+  </component>
+  <component name="UpdateCopyrightCheckinHandler">
+    <option name="UPDATE_COPYRIGHT" value="true" />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
     <option name="TAB_STATES">
       <map>
+        <entry key="4db15db6-43f4-4d5d-ad06-0fe14cfef5b2">
+          <value>
+            <State>
+              <option name="BEK_SORT_TYPE" value="1" />
+              <option name="FILTERS">
+                <map>
+                  <entry key="range">
+                    <value>
+                      <list>
+                        <option value="HEAD..a" />
+                      </list>
+                    </value>
+                  </entry>
+                  <entry key="roots">
+                    <value>
+                      <list>
+                        <option value="$PROJECT_DIR$" />
+                      </list>
+                    </value>
+                  </entry>
+                </map>
+              </option>
+            </State>
+          </value>
+        </entry>
         <entry key="MAIN">
           <value>
             <State>
               <option name="BEK_SORT_TYPE" value="1" />
+              <option name="FILTERS">
+                <map>
+                  <entry key="branch">
+                    <value>
+                      <list>
+                        <option value="origin/main" />
+                      </list>
+                    </value>
+                  </entry>
+                </map>
+              </option>
+              <option name="COLUMN_ID_WIDTH">
+                <map>
+                  <entry key="Table.Default.Author.ColumnIdWidth" value="42" />
+                  <entry key="Table.Default.Date.ColumnIdWidth" value="43" />
+                  <entry key="Table.Space.CommitStatus.ColumnIdWidth" value="43" />
+                </map>
+              </option>
             </State>
           </value>
         </entry>
       </map>
     </option>
+    <option name="OPEN_GENERIC_TABS">
+      <map>
+        <entry key="4db15db6-43f4-4d5d-ad06-0fe14cfef5b2" value="TOOL_WINDOW" />
+      </map>
+    </option>
   </component>
   <component name="VcsManagerConfiguration">
+    <option name="CHECK_CODE_CLEANUP_BEFORE_PROJECT_COMMIT_PROFILE" value="Project Default" />
+    <option name="CHECK_CODE_CLEANUP_BEFORE_PROJECT_COMMIT" value="true" />
+    <MESSAGE value="tree: self.children&#10;trigger: self.trigger" />
     <MESSAGE value="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;" />
-    <option name="LAST_COMMIT_MESSAGE" value="tree: self.children&#10;trigger: self.trigger&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;" />
+    <MESSAGE value="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;" />
+    <option name="LAST_COMMIT_MESSAGE" value="tree: self.children&#10;trigger: self.trigger&#10;&#10;# coding=utf-8&#10;&quot;&quot;&quot;&#10;Runs tox from current directory.&#10;It supports any runner, but well-known runners (py.test and unittest) are switched to our internal runners to provide&#10;better support&#10;&quot;&quot;&quot;&#10;import os&#10;import pluggy&#10;from tox import config as tox_config&#10;from tox.session import Session&#10;&#10;from tcmessages import TeamcityServiceMessages&#10;from tox import exception&#10;&#10;teamcity = TeamcityServiceMessages()&#10;&#10;hookimpl = pluggy.HookimplMarker(&quot;tox&quot;)&#10;helpers_dir = str(os.path.split(__file__)[0])&#10;&#10;class JbToxHook(object):&#10;    &quot;&quot;&quot;&#10;    Hook to report test start and test end.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, config):&#10;        self.offsets = dict()&#10;        self.current_env = None&#10;        self.config = config&#10;&#10;    @hookimpl&#10;    def tox_runtest_pre(self, venv):&#10;        &quot;&quot;&quot;&#10;        Launched before each setup.&#10;        It means prev env (if any) just finished and new is going to be created&#10;        :param venv: current virtual env&#10;        &quot;&quot;&quot;&#10;        self.current_env = venv&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        teamcity.testStarted(name, location=&quot;tox_env://&quot; + str(name), parentNodeId=&quot;0&quot;, nodeId=node_id)&#10;&#10;    @hookimpl&#10;    def tox_runtest_post(self, venv):&#10;        &quot;&quot;&quot;&#10;        Finishes currently running env. reporting its state&#10;        &quot;&quot;&quot;&#10;        if not self.current_env:&#10;            return&#10;        name = venv.name&#10;        node_id = self.offsets[name]&#10;        status = self.current_env.status&#10;        if isinstance(status, exception.InterpreterNotFound):&#10;            if self.config.option.skip_missing_interpreters:&#10;                self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;            else:&#10;                self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        elif status == &quot;platform mismatch&quot;:&#10;            self._reportFailure(&quot;SKIP&quot;, status, node_id)&#10;        elif status and status == &quot;ignored failed command&quot;:&#10;            print(&quot;  %s: %s&quot; % (self.current_env.name, str(status)))&#10;        elif status and status != &quot;skipped tests&quot;:&#10;            self._reportFailure(&quot;ERROR&quot;, status, node_id)&#10;        else:&#10;            teamcity.testStdOut(self.current_env.name, &quot;\n&quot;, nodeId=node_id)&#10;            teamcity.testFinished(self.current_env.name, nodeId=node_id)&#10;        self.current_env = None&#10;&#10;    def _reportFailure(self, state, message, node_id):&#10;        &quot;&quot;&quot;sleep until we depaarted&#10;        In idBased mode each test is leaf, there is no suites, so we can rerport directly to the test&#10;        :param state: SKIP or ERROR (suite result)&#10;        &quot;&quot;&quot;&#10;        if state == &quot;SKIP&quot;:&#10;            teamcity.testIgnored(state, str(message), nodeId=node_id)&#10;        else:&#10;            teamcity.testFailed(state, str(message), nodeId=node_id)&#10;&#10;class Fixer(object):&#10;    def __init__(self, runner_name):&#10;        self.runner_name = runner_name&#10;&#10;    def fix(self, command, bin, offset):&#10;        return [bin, os.path.join(helpers_dir, self.runner_name), &quot;--offset&quot;, str(offset), &quot;--&quot;]&#10;&#10;    def is_parallel(self, *args, **kwargs):&#10;        return False&#10;&#10;class _Unit2(Fixer):&#10;    def __init__(self):&#10;        super(_Unit2, self).__init__(&quot;_jb_unittest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] == &quot;unit2&quot;:&#10;            return [bin, os.path.join(helpers_dir, &quot;utrunner.py&quot;)] + command[1:] + [&quot;true&quot;]&#10;        elif command == [&quot;python&quot;, &quot;-m&quot;, &quot;unittest&quot;, &quot;discover&quot;]:&#10;            return super(_Unit2, self).fix(command, bin, offset) + [&quot;discover&quot;]&#10;        return None&#10;&#10;class _PyTest(Fixer):&#10;    def __init__(self):&#10;        super(_PyTest, self).__init__(&quot;_jb_pytest_runner.py&quot;)&#10;&#10;    def is_parallel(self, config):  # If xdist is used, then pytest will use parallel run&#10;        deps = getattr(config, &quot;deps&quot;, [])&#10;        return bool([d for d in deps if d.name == &quot;pytest-xdist&quot;])&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] not in [&quot;pytest&quot;, &quot;py.test&quot;]:&#10;            return None&#10;        return super(_PyTest, self).fix(command, bin, offset) + command[1:]&#10;&#10;class _Nose(Fixer):&#10;    def __init__(self):&#10;        super(_Nose, self).__init__(&quot;_jb_nosetest_runner.py&quot;)&#10;&#10;    def fix(self, command, bin, offset):&#10;        if command[0] != &quot;nosetests&quot;:&#10;            return None&#10;        return super(_Nose, self).fix(command, bin, offset) + command[1:]&#10;&#10;_RUNNERS = [_Unit2(), _PyTest(), _Nose()]&#10;&#10;import sys&#10;&#10;durationStrategy = &quot;automatic&quot;&#10;config = tox_config.parseconfig(args=sys.argv[1:])&#10;hook = JbToxHook(config)&#10;config.pluginmanager.register(hook, &quot;jbtoxplugin&quot;)&#10;offset = 1&#10;for env, tmp_config in config.envconfigs.items():&#10;    hook.offsets[env] = offset&#10;    if not tmp_config.setenv:&#10;        tmp_config.setenv = dict()&#10;    tmp_config.setenv[&quot;_jb_do_not_call_enter_matrix&quot;] = &quot;1&quot;&#10;    commands = tmp_config.commands&#10;&#10;    if &quot;_jb_do_not_patch_test_runners&quot; not in os.environ and isinstance(commands, list):&#10;        for fixer in _RUNNERS:&#10;            _env = config.envconfigs[env]&#10;            for i, command in enumerate(commands):&#10;                if command:&#10;                    fixed_command = fixer.fix(command, str(_env.envpython), offset)&#10;                    if fixer.is_parallel(tmp_config):&#10;                        durationStrategy = &quot;manual&quot;&#10;                    if fixed_command:&#10;                        commands[i] = fixed_command&#10;    tmp_config.commands = commands&#10;    offset += 10000&#10;&#10;session = Session(config)&#10;teamcity.testMatrixEntered(durationStrategy=durationStrategy)&#10;sys.exit(session.runcommand())&#10;&#10;Signed-off-by: sad1234558 &lt;52356708+sad1234558@users.noreply.github.com&gt;" />
+    <option name="OPTIMIZE_IMPORTS_BEFORE_PROJECT_COMMIT" value="true" />
+    <option name="REFORMAT_BEFORE_PROJECT_COMMIT" value="true" />
+    <option name="REARRANGE_BEFORE_PROJECT_COMMIT" value="true" />
+  </component>
+  <component name="XDebuggerManager">
+    <breakpoint-manager>
+      <default-breakpoints>
+        <breakpoint enabled="true" type="java-exception" />
+      </default-breakpoints>
+    </breakpoint-manager>
+  </component>
+  <component name="XSLT-Support.FileAssociations.UIState">
+    <expand />
+    <select />
   </component>
 </project>
\ No newline at end of file
Index: .idea/artifacts/unnamed.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/artifacts/unnamed.xml b/.idea/artifacts/unnamed.xml
new file mode 100644
--- /dev/null	(date 1650490152457)
+++ b/.idea/artifacts/unnamed.xml	(date 1650490152457)
@@ -0,0 +1,6 @@
+<component name="ArtifactManager">
+  <artifact type="javafx-preloader" build-on-make="true" name="unnamed">
+    <output-path>$PROJECT_DIR$/out/artifacts/unnamed</output-path>
+    <root id="archive" name="unnamed.jar" />
+  </artifact>
+</component>
\ No newline at end of file
Index: .idea/runConfigurations/traceback.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"ProjectRunConfigurationManager\">\r\n  <configuration default=\"false\" name=\"traceback\" type=\"PythonConfigurationType\" factoryName=\"Python\" singleton=\"false\" nameIsGenerated=\"true\">\r\n    <module name=\"Google\" />\r\n    <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n    <option name=\"PARENT_ENVS\" value=\"true\" />\r\n    <option name=\"SDK_HOME\" value=\"C:\\Users\\andjo\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\demo\\PyCharmLearningProject\\venv\\Scripts\\python.exe\" />\r\n    <option name=\"WORKING_DIRECTORY\" value=\"$APPLICATION_HOME_DIR$/jbr/bin\" />\r\n    <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n    <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n    <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n    <option name=\"SCRIPT_NAME\" value=\"$USER_HOME$/AppData/Local/Programs/Python/Python39/Lib/traceback.py\" />\r\n    <option name=\"PARAMETERS\" value=\"\" />\r\n    <option name=\"SHOW_COMMAND_LINE\" value=\"true\" />\r\n    <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n    <option name=\"MODULE_MODE\" value=\"false\" />\r\n    <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n    <option name=\"INPUT_FILE\" value=\"\" />\r\n    <method v=\"2\" />\r\n  </configuration>\r\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/runConfigurations/traceback.xml b/.idea/runConfigurations/traceback.xml
--- a/.idea/runConfigurations/traceback.xml	(revision f7993c5a5ea97154f180c6b4f2622e4d15c72fe0)
+++ b/.idea/runConfigurations/traceback.xml	(date 1650489838593)
@@ -3,7 +3,7 @@
     <module name="Google" />
     <option name="INTERPRETER_OPTIONS" value="" />
     <option name="PARENT_ENVS" value="true" />
-    <option name="SDK_HOME" value="C:\Users\andjo\AppData\Local\JetBrains\PyCharmCE2021.3\demo\PyCharmLearningProject\venv\Scripts\python.exe" />
+    <option name="SDK_HOME" value="" />
     <option name="WORKING_DIRECTORY" value="$APPLICATION_HOME_DIR$/jbr/bin" />
     <option name="IS_MODULE_SDK" value="false" />
     <option name="ADD_CONTENT_ROOTS" value="true" />
Index: .idea/runConfigurations/xxx_py.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"ProjectRunConfigurationManager\">\r\n  <configuration default=\"false\" name=\"xxx.py\" type=\"Tox\" factoryName=\"Tox\" editBeforeRun=\"true\" singleton=\"false\">\r\n    <output_file path=\"asda\" is_save=\"true\" />\r\n    <module name=\"Google\" />\r\n    <option name=\"INTERPRETER_OPTIONS\" value=\"omt\" />\r\n    <option name=\"PARENT_ENVS\" value=\"true\" />\r\n    <option name=\"SDK_HOME\" value=\"\" />\r\n    <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Portfolio _ Robinhood_files\" />\r\n    <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n    <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n    <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n    <EXTENSION ID=\"net.ashald.envfile\">\r\n      <option name=\"IS_ENABLED\" value=\"true\" />\r\n      <option name=\"IS_SUBST\" value=\"true\" />\r\n      <option name=\"IS_PATH_MACRO_SUPPORTED\" value=\"true\" />\r\n      <option name=\"IS_IGNORE_MISSING_FILES\" value=\"true\" />\r\n      <option name=\"IS_ENABLE_EXPERIMENTAL_INTEGRATIONS\" value=\"true\" />\r\n      <ENTRIES>\r\n        <ENTRY IS_ENABLED=\"true\" PARSER=\"runconfig\" />\r\n        <ENTRY IS_ENABLED=\"true\" PARSER=\"env\" PATH=\"$USER_HOME$/.Wurst encryption/READ ME I AM VERY IMPORTANT.txt\" />\r\n        <ENTRY IS_ENABLED=\"true\" PARSER=\"env\" PATH=\"$USER_HOME$/.Wurst encryption/READ ME I AM VERY IMPORTANT.txt\" />\r\n      </ENTRIES>\r\n    </EXTENSION>\r\n    <arguments>\r\n      <array>\r\n        <option value=\"AI\" />\r\n      </array>\r\n    </arguments>\r\n    <runOnlyEnvs>\r\n      <array>\r\n        <option value=\"py\" />\r\n        <option value=\"AI.c++\" />\r\n      </array>\r\n    </runOnlyEnvs>\r\n    <method v=\"2\">\r\n      <option name=\"ToolBeforeRunTask\" enabled=\"true\" actionId=\"Tool_External Tools_console\" />\r\n      <option name=\"RunConfigurationTask\" enabled=\"true\" run_configuration_name=\"Goldie\" run_configuration_type=\"CompoundRunConfigurationType\" />\r\n      <option name=\"LaunchBrowser.Before.Run\" url=\"Default\" />\r\n      <option name=\"RunConfigurationTask\" enabled=\"true\" run_configuration_name=\"Goldiev1\" run_configuration_type=\"CompoundRunConfigurationType\" />\r\n      <option name=\"LaunchBrowser.Before.Run\" url=\"https://robinhood.com/?region=US\" />\r\n      <option name=\"ToolBeforeRunTask\" enabled=\"true\" actionId=\"Tool_External Tools_Toolbox\" />\r\n    </method>\r\n  </configuration>\r\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/runConfigurations/xxx_py.xml b/.idea/runConfigurations/xxx_py.xml
--- a/.idea/runConfigurations/xxx_py.xml	(revision f7993c5a5ea97154f180c6b4f2622e4d15c72fe0)
+++ b/.idea/runConfigurations/xxx_py.xml	(date 1650489687284)
@@ -2,9 +2,9 @@
   <configuration default="false" name="xxx.py" type="Tox" factoryName="Tox" editBeforeRun="true" singleton="false">
     <output_file path="asda" is_save="true" />
     <module name="Google" />
-    <option name="INTERPRETER_OPTIONS" value="omt" />
+    <option name="INTERPRETER_OPTIONS" value="" />
     <option name="PARENT_ENVS" value="true" />
-    <option name="SDK_HOME" value="" />
+    <option name="SDK_HOME" value="D:\Testing\python.exe" />
     <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/Portfolio _ Robinhood_files" />
     <option name="IS_MODULE_SDK" value="true" />
     <option name="ADD_CONTENT_ROOTS" value="true" />
@@ -34,7 +34,6 @@
     </runOnlyEnvs>
     <method v="2">
       <option name="ToolBeforeRunTask" enabled="true" actionId="Tool_External Tools_console" />
-      <option name="RunConfigurationTask" enabled="true" run_configuration_name="Goldie" run_configuration_type="CompoundRunConfigurationType" />
       <option name="LaunchBrowser.Before.Run" url="Default" />
       <option name="RunConfigurationTask" enabled="true" run_configuration_name="Goldiev1" run_configuration_type="CompoundRunConfigurationType" />
       <option name="LaunchBrowser.Before.Run" url="https://robinhood.com/?region=US" />
Index: .idea/runConfigurations/Goldie.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"ProjectRunConfigurationManager\">\r\n  <configuration default=\"false\" name=\"Goldie\" type=\"CompoundRunConfigurationType\">\r\n    <toRun name=\"Unnamed (1)\" type=\"CompoundRunConfigurationType\" />\r\n    <toRun name=\"Unnamed (2)\" type=\"CompoundRunConfigurationType\" />\r\n    <method v=\"2\" />\r\n  </configuration>\r\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/runConfigurations/Goldie.xml b/.idea/runConfigurations/Goldie.xml
--- a/.idea/runConfigurations/Goldie.xml	(revision f7993c5a5ea97154f180c6b4f2622e4d15c72fe0)
+++ b/.idea/runConfigurations/Goldie.xml	(date 1650489687285)
@@ -1,7 +1,6 @@
 <component name="ProjectRunConfigurationManager">
   <configuration default="false" name="Goldie" type="CompoundRunConfigurationType">
-    <toRun name="Unnamed (1)" type="CompoundRunConfigurationType" />
-    <toRun name="Unnamed (2)" type="CompoundRunConfigurationType" />
+    <toRun name="scratch" type="PythonConfigurationType" />
     <method v="2" />
   </configuration>
 </component>
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"VcsDirectoryMappings\">\r\n    <mapping directory=\"$PROJECT_DIR$\" vcs=\"Git\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
--- a/.idea/vcs.xml	(revision f7993c5a5ea97154f180c6b4f2622e4d15c72fe0)
+++ b/.idea/vcs.xml	(date 1650489799930)
@@ -1,6 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$/../D" vcs="Git" />
     <mapping directory="$PROJECT_DIR$" vcs="Git" />
   </component>
 </project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision f7993c5a5ea97154f180c6b4f2622e4d15c72fe0)
+++ b/.idea/misc.xml	(date 1650489684411)
@@ -1,4 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="FrameworkDetectionExcludesConfiguration">
+    <type id="android" />
+  </component>
   <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
